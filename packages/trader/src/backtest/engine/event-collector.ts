/**
 * Event Collector for Backtest Engine
 *
 * Captures all events during a backtest run for visualization and analysis.
 * This is the key component that enables correlating signals → trades → charts.
 */

import type { Candle, MarketSnapshot, IndicatorSnapshot, TradeWithContext } from '@deriv-bot/shared';
import type {
  BacktestEvent,
  CandleEvent,
  SignalEvent,
  EntryEvent,
  ExitEvent,
  TradeCompleteEvent,
  EntrySignal,
  TradeEntry,
  ExitReason,
  BacktestConfig,
  BacktestMetrics,
  BacktestResult,
  MonteCarloResult,
  WalkForwardResult,
  OOSResult,
} from '../types.js';

/**
 * EventCollector captures all events during backtest execution
 * and can produce a complete BacktestResult with visualization data
 */
export class EventCollector {
  private events: BacktestEvent[] = [];
  private candles: Candle[] = [];
  private indicatorHistory: Map<string, number[]> = new Map();
  private trades: TradeWithContext[] = [];
  private startTime: number = 0;

  private readonly asset: string;
  private readonly timeframe: number;
  private readonly strategyName: string;
  private readonly strategyVersion: string;
  private readonly config: BacktestConfig;

  constructor(
    asset: string,
    timeframe: number,
    strategyName: string,
    strategyVersion: string,
    config: BacktestConfig
  ) {
    this.asset = asset;
    this.timeframe = timeframe;
    this.strategyName = strategyName;
    this.strategyVersion = strategyVersion;
    this.config = config;
  }

  /**
   * Initialize the collector before starting a backtest
   */
  init(): void {
    this.events = [];
    this.candles = [];
    this.indicatorHistory.clear();
    this.trades = [];
    this.startTime = Date.now();
  }

  /**
   * Record a candle with its indicators
   */
  onCandle(candle: Candle, index: number, indicators: IndicatorSnapshot): void {
    this.candles.push(candle);

    // Store indicator values in series
    for (const [key, value] of Object.entries(indicators)) {
      if (typeof value === 'number') {
        if (!this.indicatorHistory.has(key)) {
          this.indicatorHistory.set(key, []);
        }
        this.indicatorHistory.get(key)!.push(value);
      } else if (typeof value === 'boolean') {
        // Convert boolean to number for charting
        if (!this.indicatorHistory.has(key)) {
          this.indicatorHistory.set(key, []);
        }
        this.indicatorHistory.get(key)!.push(value ? 1 : 0);
      }
    }

    const event: CandleEvent = {
      type: 'candle',
      timestamp: candle.timestamp,
      data: { candle, index, indicators },
    };
    this.events.push(event);
  }

  /**
   * Record a signal generated by the strategy
   */
  onSignal(signal: EntrySignal): void {
    const event: SignalEvent = {
      type: 'signal',
      timestamp: signal.timestamp,
      data: signal,
    };
    this.events.push(event);
  }

  /**
   * Record trade entry
   */
  onEntry(tradeId: string, entry: TradeEntry, snapshot: MarketSnapshot): void {
    const event: EntryEvent = {
      type: 'entry',
      timestamp: entry.timestamp,
      data: { tradeId, entry, snapshot },
    };
    this.events.push(event);
  }

  /**
   * Record trade exit
   */
  onExit(
    tradeId: string,
    exitPrice: number,
    exitReason: ExitReason,
    snapshot: MarketSnapshot
  ): void {
    const event: ExitEvent = {
      type: 'exit',
      timestamp: snapshot.timestamp,
      data: { tradeId, exitPrice, exitReason, snapshot },
    };
    this.events.push(event);
  }

  /**
   * Record a completed trade with full context
   */
  onTradeComplete(trade: TradeWithContext): void {
    this.trades.push(trade);

    const event: TradeCompleteEvent = {
      type: 'trade_complete',
      timestamp: trade.entry.snapshot.timestamp,
      data: trade,
    };
    this.events.push(event);
  }

  /**
   * Get all recorded events
   */
  getEvents(): BacktestEvent[] {
    return [...this.events];
  }

  /**
   * Get all completed trades
   */
  getTrades(): TradeWithContext[] {
    return [...this.trades];
  }

  /**
   * Get all candles
   */
  getCandles(): Candle[] {
    return [...this.candles];
  }

  /**
   * Get indicator series for visualization
   */
  getIndicatorSeries(): Map<string, number[]> {
    return new Map(this.indicatorHistory);
  }

  /**
   * Convert collected data to complete BacktestResult
   */
  toBacktestResult(
    metrics: BacktestMetrics,
    monteCarlo?: MonteCarloResult,
    walkForward?: WalkForwardResult,
    oosTest?: OOSResult
  ): BacktestResult {
    const executionTimeMs = Date.now() - this.startTime;

    // Determine date range from candles
    const firstCandle = this.candles[0];
    const lastCandle = this.candles[this.candles.length - 1];

    const dateRange = {
      from: firstCandle ? new Date(firstCandle.timestamp * 1000) : new Date(),
      to: lastCandle ? new Date(lastCandle.timestamp * 1000) : new Date(),
      candleCount: this.candles.length,
    };

    return {
      asset: this.asset,
      timeframe: this.timeframe,
      strategyName: this.strategyName,
      strategyVersion: this.strategyVersion,
      config: this.config,
      dateRange,
      trades: this.trades,
      metrics,
      candles: this.candles,
      indicatorSeries: this.indicatorHistory,
      monteCarlo,
      walkForward,
      oosTest,
      executedAt: new Date(),
      executionTimeMs,
    };
  }

  /**
   * Get events filtered by type
   */
  getEventsByType<T extends BacktestEvent>(type: T['type']): T[] {
    return this.events.filter((e) => e.type === type) as T[];
  }

  /**
   * Get signals that resulted in trades
   */
  getExecutedSignals(): EntrySignal[] {
    return this.trades.map((t) => t.signal.snapshot.indicators as unknown as EntrySignal);
  }

  /**
   * Get summary statistics
   */
  getSummary(): {
    totalCandles: number;
    totalSignals: number;
    totalTrades: number;
    totalEvents: number;
    indicatorsTracked: string[];
  } {
    const signals = this.getEventsByType<SignalEvent>('signal');

    return {
      totalCandles: this.candles.length,
      totalSignals: signals.length,
      totalTrades: this.trades.length,
      totalEvents: this.events.length,
      indicatorsTracked: Array.from(this.indicatorHistory.keys()),
    };
  }
}

/**
 * Create a new EventCollector instance
 */
export function createEventCollector(
  asset: string,
  timeframe: number,
  strategyName: string,
  strategyVersion: string,
  config: BacktestConfig
): EventCollector {
  const collector = new EventCollector(
    asset,
    timeframe,
    strategyName,
    strategyVersion,
    config
  );
  collector.init();
  return collector;
}
